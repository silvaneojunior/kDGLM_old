---
title: "Exemplos de uso do pacote GDLM"
subtitle: "Modelos AR"
author: "Silvaneo Viera dos Santos Junior"
date: "`r Sys.Date()`"
output: rmdformats::readthedown

---

```{css, echo=FALSE}
#content{
    max-width:1200px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	fig.height = 6,
	fig.width = 10,
	warning = FALSE
)
library(tidyverse)
library(latex2exp)
library(rmdformats)
 options(scipen=99)
```


## Introdução

Este documento tem como intuito apresentar o pacote GDLM para ajuste de Modelos Dinâmicos Lineares Generalizados, em especial, para modelos com blocos estruturais auto-regressivos.

Antes de apresentar o pacote, é importante ressaltar que este ainda é um trabalho em progresso, de modo que as funcionalidades mais recentes ainda podem apresentar comportamentos inesperados. Nesse sentido, o pacote está disponível apenas para uso experimental.

O primeiro passo para o uso do pacote é, naturalmente, a sua instalação. A versão mais recente do pacote está sempre disponível [neste repositório](https://github.com/silvaneojunior/GDLM). O processo de instalação pode ser trivialmente realizado através do seguinte comando:

```{r eval=FALSE}
devtools::install_github('silvaneojunior/GDLM')
```

Uma vez instalado o pacote, basta importar o pacote GDLM como qualquer outro pacote:

```{r}
# library(GDLM)
devtools::load_all()
```

A principal função do pacote é chamada *fit_model* e serve justamente para ajustar os modelos. O uso dessa função é feita da seguinte forma:

```{r eval=FALSE}
fit_model(
  ...,
  outcome,
  family,
  offset = outcome * 0 + 1,
  parms = list(),
  pred_cred = 0.95,
  smooth_flag = TRUE,
  p_monit = NA,
  c_monit = 1
)
```

Os argumentos não nomeados desta função são os blocos estruturais que compões o modelo (blocos harmônicos, polinomiais, AR, etc.) e são responsáveis por estabelecera dinâmica temporal do modelo e a relação entre as variáveis latentes e os preditores lineares (é possível que exista mais de um). Além da estrutura do modelo, o usuário deve passar um lista de valores como *outcome* que serão usados como desfecho para o ajuste do modelo, ademais, o usuário também deve especificar a família da distribuição do desfecho (condicionado às variáveis latentes). Atualmente as famílias disponíveis são:

- Poisson;
- Gamma com parâmetro de forma conhecidos;
- Gamma com parâmetro de forma desconhecido (esse caso é chamado de *FGamma*);
- Normal multivariada com matriz de covariância conhecida;
- Normal univariada com covariância desconhecida;
- Multinomial com $k$ categorias e total de ocorrências conhecido (o $k$ pode ser qualquer, mas deve ser o mesmo ao longo das iterações).

É importante observar que todas as funcionalidades do pacote estão disponíveis para todas as possíveis famílias da distribuição do desfecho.

As informações acima são apenas um breve resumo do uso da função *fit_model*, mais informações e exemplos de uso estão disponíveis no *help*.

Por último, para que o usuário possa fazer o ajuste de um modelo, resta apenas especificar sua estrutura. Para o ajuste dos modelos, estamos supondo que:

$$
\begin{aligned}
Y_t|\eta_t &\sim \mathcal{F}(\eta_t),\\
g(\eta_t)&=F_t'\theta_t,\\
\theta_t&=G_t\theta_{t-1}+\epsilon_t,\\
\epsilon_t &\sim \mathcal{N}(0,W_t),
\end{aligned}
$$
onde $\mathcal{F}$ é uma das distribuições disponíveis do pacote e é indexada pelo parâmetro $\eta_t$, $g$ é a função de ligação, $F_t$ é a matriz de planejamento, $G_t$ é a matriz que define a evolução temporal do modelo, $\epsilon_t$ é um ruído com distribuição Normal multivariada e $W_t$ é uma matriz de covariância conhecida. Uma vez escolhida a família da distribuição do desfecho, $g$ e $\eta$ estarão definidos, restando ao usuário definir $F_t$, $G_t$, $W_t$ e $\theta_t$ (no caso de $\theta_t$, o usuário não irá definir seus valores, mas sim a sua dimensão e uma priori para $theta_0$).

Para auxiliar a definição de $F_t$, $G_t$ e $W_t$, algumas funções são disponibilizadas para criar estruturas já pré-estabelecidas. As funções disponíveis são *polynomial_block*, *harmonic_block* e *AR_block* (mais opções estão em desenvolvimento), sendo que neste documento daremos ênfase ao uso da função *AR_block*, porém, mais informações e exemplos de uso podem ser encontrados no *help* de todas as funções.

Por último, antes de partirmos para a apresentação dos exemplos de uso dos modelo *AR* apresentamos um exemplo simples com dados simulados do ajuste de um modelo dinâmico Poisson:

```{r}
# Simulando dados para o exemplo
T <- 200
w <- (200 / 40) * 2 * pi
outcome <- rpois(T, exp(2 + (sin(w * 1:T / T))))

# Criando estrutura de primeira ordem para o modelo.
level <- polynomial_block(order = 1, D = 1 / 0.95,name='nivel')
# Criando estrutura sazonal para o modelo
season <- harmonic_block(period = 40, D = 1 / 0.98,name='sazonalidade')
# O argumento D é um argumento auxiliar que permite a especificação da matriz W_t através de fatores de desconto.
# Vale observar que, no modelo Poisson, estaremos colocando estrutura sob o logaritmo da taxa.
# Ademais, o argumento name é opcional em todos os blocos, porém ele é útil para facilitar a identificação das variáveis após o ajuste do modelo

fitted_data <- fit_model(level, season, outcome = outcome, family = "Poisson")

# A função show_fit é uma função auxiliar para a exibição do modelo ajustado
show_fit(fitted_data, smooth = TRUE)$plot

# A função plot_lat_var é uma função auxiliar para a exibição dos parâmetros latentes
# Essa função exige que você especifique os parâmetros a serem plotados pelo nome dado durante a criação (caso o usuário não tenha especificado um nome, são dados nomes padrões)
# Caso o usuário queira visualizar todas as variáveis, basta passar uma string vazia
plot_lat_var(fitted_data, 'sazonalidade')$plot
plot_lat_var(fitted_data, '')$plot

# É válido destacar que, apesar dos gráficos default serem dinâmicos, é possível solicitar também gráficos estáticos. Nesse caso, as funções auxiliares retornarão um objeto do ggplot que pode ser modificado pelo usuário.
```

Nesta sessão apresentamos muito brevemente as principais funcionalidades do pacote, mostrando apenas o básico para que possamos abordar o uso da estrutura *AR*, por isso, recomendamos fortemente que o usuário consulte a documentação no *help* para informações mais detalhadas sobre o uso de cada função.

## Exemplos com estrutura AR {.tabset}

Nos exemplos a seguir faremos o ajuste de Modelos Normais com média e variância desconhecidas, onde vamos supor que nossas observações $Y_t$ são tais que:

$$
\begin{aligned}
Y_t|\eta_t &\sim \mathcal{N}(\mu_t,\sigma_t^2),\\
\mu_t&=\sum_{i=1}^{p}\phi_i \mu_{t-i}+\epsilon_t,\\
\sigma_t^2&=\sigma^2, \forall t,\\
\epsilon_t &\sim \mathcal{N}(0,W_t)\\
\end{aligned}
$$
isto é, vamos supor que a média do modelo tem estrutura *AR(p)* e a variância é constante, mas desconhecida. Vale destacar que $W_t$ deve ser conhecida (pode ser especificada através de fatores de desconto). Os códigos apresentados podem ser muito facilmente adaptados para as demais distribuições.

### Exemplo 1: AR(2) para dados de COVID

Neste exemplo vamos ajustar um modelo para dados reais tomando $r=2$.

Adiante exibimos os dados usados para o ajuste (do dia 1 ao 500) junto com os dados reservados para teste (do dia 501 ao dia 754).

```{r echo=FALSE}
dados=read.delim('data/dados_covid_migon.txt')
outcome_full=dados[,2]
outcome=outcome_full[1:500]
T=length(outcome)
T_full=length(outcome_full)
outcome_test=outcome_full[501:T_full]

ggplot()+
  geom_point(aes(x=1:T_full,y=outcome_full,color=ifelse(1:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão')))+
  scale_x_continuous('Índice do dia',breaks=seq(90,T_full,90))+
  scale_y_continuous('Óbitos',labels=function(x){formatC(x,format='f',digits=0,big.mark=',')})+
  scale_color_manual('',values=c('black','grey'))+
  labs(title='Evolução dos óbitos diários por COVID')+
  theme_bw()
```

Vamos assumir o seguinte modelo para os dados:

$$
\begin{aligned}
Y_t|\theta_t &\sim Poisson(\lambda_t),\\
\ln(\lambda_t)&=\theta_t,\\
\theta_t&=\phi_{t}^{(1)}\theta_{t-1}+\phi_{t}^{(2)}\theta_{t-2}+\epsilon_t,\\
\phi_{t}^{(i)}&=\phi_{t-1}^{(i)}+\omega^{(i)}_t,
\end{aligned}
$$

onde $Y_t$ é a quantidade de óbitos no dia $t$ e $\epsilon_{t}$, $\omega^{(1)}_t$ e $\omega^{(2)}_t$ são ruídos normais com média 0 e variância especificada através de fatores de desconto. Para a escolha dos fatores de desconto, testamos diversos valores (valores distintos para cada parâmetro) e tomamos a combinação que gerou o melhor ajuste, sendo que usamos o erro média absoluto relativo para comparar a qualidade dos ajustes. Adiante exibimos o código para o ajuste do modelo:

```{r}
# Observações sobre a especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.

block1=AR_block(order=2,
                values=1,
                by_time=FALSE,
                D=diag(c(1/0.9,1/0.9933333,1/1,1/0.9966667)),
                m0=c(0,0.1,0,-0.1),
                W=diag(c(0.0,0,0,0)),
                name='AR')

model=fit_model(block1,
                outcome = outcome,
                family='Poisson')
```

No gráfico a seguir exibimos os dados observados contra a distribuição da previsão um passo frente. Ademais incluimos também os dados de teste, sendo que para esses dados, fizemos a previsão com base nas observações usadas no ajuste.

```{r}
pred=forecast(model,T_full-T)
fore=pred$pred

(ggplot()+
  geom_point(aes(x=31:T_full,y=outcome_full[31:T_full],color=ifelse(31:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão'),fill=ifelse(31:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão'),linetype=ifelse(31:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão')))+
  geom_line(aes(x=31:T_full,y=c(model$pred[31:T],fore),linetype=ifelse(31:T_full<=500,'Ajuste','Previsão'),color=ifelse(31:T_full<=500,'Ajuste','Previsão'),fill=ifelse(31:T_full<=500,'Ajuste','Previsão')))+
  geom_ribbon(aes(x=31:T_full,
                  ymin=c(model$icl.pred[31:T],pred$icl.pred),
                  ymax=c(model$icu.pred[31:T],pred$icu.pred),
                  linetype=ifelse(31:T_full<=500,'Ajuste','Previsão'),
                  fill=ifelse(31:T_full<=500,'Ajuste','Previsão'),
                  color=ifelse(31:T_full<=500,'Ajuste','Previsão')),alpha=0.25)+
  scale_x_continuous('Índice do dia',breaks=seq(90,T_full,90))+
  scale_y_continuous('Óbitos',labels=function(x){formatC(x,format='f',digits=0,big.mark=',')})+
  scale_color_manual('',values=c('lightblue','black','#aaaaaa','red'))+
  scale_fill_manual('',values=c('lightblue','black','#aaaaaa','red'))+
  scale_linetype('')+
  labs(title='Evolução dos óbitos diários por COVID')+
  theme_bw()) %>% ggplotly
```


Veja que o ajsute é muito bom até o momento $500$, onde o modelo tinha acesso aos dados observados, porém após esse instante o ajuste para de acompanhar os dados. Isso acontece devido ao fato de os valores estimados de $\phi_{t}^{(1)}$ e $\phi_{t}^{(2)}$ implicam em um modelo AR estacionário e cuja média converge a $0$, por conta disso, como a previsão é feita sem utilizar as observações de teste, temos que a média da previsão acaba convergindo a $0$. Para validar essa observação, vamos exibir adiante o gráfico dos parâmetros do modelo ao longo do tempo:


```{r}
plot_lat_var(model,'')$plot
```

Observe que não podemos atualizar os valores de $\theta_t$ com $t>500$ a menos que realizemos o processo de filtragem, uma vez que a estrutura AR está em $\ln(\lambda_t)$ e $lambda_t$ não é observável.

Para contornar o problema apresentado acima, vamos apresentar uma "versão alternativa" do ajuste para os dados de teste. Nessa versão vamos usar os últimos valors de $\phi_{t}^{(1)}$ e $\phi_{t}^{(2)}$ como valores "verdadeiros" e usar que $\lambda_t \approx Y_t$, pois como $\lambda_t$ é muito grande, a distribuição de $Y_t$ é aproximadamente normal com média e variância $\lambda_t$, isso faz com que $\mathbb{P}(\lambda_t-1.96\sqrt{\lambda_t}<Y_t<\lambda_t+1.96\sqrt{\lambda_t})=0.95$, ou seja, para $\lambda_t$ próximo de 1.000.000 (como é o nosso caso), temos que $\mathbb{P}(0.99804<Y_t/\lambda_t<1.00196)=0.95$, isto é, em termos relativos, $Y_t$ está bem concentrado ao redor de $\lambda_t$, sendo razoável usar $\lambda_t \approx Y_t$. Com essas simplificações, temos que, para $t>500$:

$$
\ln(\lambda_t) = \phi_t^{(1)}Y_{t-1} + \phi_t^{(2)}Y_{t-2}.
$$

Usando a igualdade acima, vamos reapresentar o ajuste do modelo substituindo a previsão para os dados de teste pelo seu valor aproximada previsto (todos os outros parâmetros e estimativas continuam iguais):

```{r}
phi1=model$mts[2,T]
phi2=model$mts[4,T]
pred=rep(NA,T_full-T)
mu1=model$mts[1,T]
mu2=model$mts[3,T]
for(t in 1:(T_full-T)){
  pred[t]=exp(phi1*mu1+phi2*mu2)
  mu2=mu1
  mu1=log(outcome_test[t])
}

(ggplot()+
  geom_point(aes(x=31:T_full,y=outcome_full[31:T_full],color=ifelse(31:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão'),linetype=ifelse(31:T_full<=500,'Dados para\no ajuste','Dados para\nprevisão')))+
  geom_line(aes(x=31:T_full,y=c(model$pred[31:T],pred),linetype=ifelse(31:T_full<=500,'Ajuste','Previsão'),color=ifelse(31:T_full<=500,'Ajuste','Previsão')))+
  scale_x_continuous('Índice do dia',breaks=seq(90,T_full,90))+
  scale_y_continuous('Óbitos',labels=function(x){formatC(x,format='f',digits=0,big.mark=',')})+
  scale_color_manual('',values=c('lightblue','black','#aaaaaa','red'))+
  scale_linetype('')+
  labs(title='Evolução dos óbitos diários por COVID')+
  theme_bw()) %>% ggplotly
```

Pelo gráfico acima podemos observar que a previsão do modelo nos dados de teste é excelente (lembrando que esta previsão se baseia na estimativa dos coeficientes do AR). Vale observar que, de fato, no gráfico das variáveis latentes, não parece que os coeficientes do AR mudam muito ao longo do tempo e parece que, de fato, eles não mudam drásticamente após o dia 500, uma vez que os valores estimados geram boas previsões.

Por último, mais a título de curiosidade, apresentamos o ajuste do modelo usando todos os dados:

```{r}
# Observações sobre a especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.

block1=AR_block(order=2,
                values=1,
                by_time=FALSE,
                D=diag(c(1/0.9,1/0.9933333,1/1,1/0.9966667)),
                m0=c(0,0.1,0,-0.1),
                W=diag(c(0.0,0,0,0)),
                name='AR')

model=fit_model(block1,
                outcome = outcome_full,
                family='Poisson')
```


```{r}
(ggplot()+
  geom_point(aes(x=31:T_full,y=outcome_full[31:T_full],color=ifelse(31:T_full<=T_full,'Dados para\no ajuste','Dados para\nprevisão'),linetype=ifelse(31:T_full<=T_full,'Dados para\no ajuste','Dados para\nprevisão')))+
  geom_line(aes(x=31:T_full,y=model$pred[31:T_full],linetype=ifelse(31:T_full<=T_full,'Ajuste','Previsão'),color=ifelse(31:T_full<=T_full,'Ajuste','Previsão')))+
  geom_ribbon(aes(x=31:T_full,
                  ymin=model$icl.pred[31:T_full],
                  ymax=model$icu.pred[31:T_full],
                  linetype=ifelse(31:T_full<=T_full,'Ajuste','Previsão'),
                  color=ifelse(31:T_full<=T_full,'Ajuste','Previsão')))+
  scale_x_continuous('Índice do dia',breaks=seq(90,T_full,90))+
  scale_y_continuous('Óbitos',labels=function(x){formatC(x,format='f',digits=0,big.mark=',')})+
  scale_color_manual('',values=c('lightblue','black','#aaaaaa','red'))+
  scale_linetype('')+
  labs(title='Evolução dos óbitos diários por COVID')+
  theme_bw()) %>% ggplotly
```

```{r}
plot_lat_var(model,'')$plot
```
Novamente, não encontramos evidências de que os coeficientes do AR mudam com o tempo, o que explica o por que que o ajuste do modelo com todos os dados tem o desempenho semelhante ao modelo ajustado apenas com os primeiros 500 dias.

### Exemplo 2: AR(1)

Neste exemplo vamos tomar $r=1$ e $\phi_1=0.75$. A seguir apresentamos o código de simulação dos dados:

```{r}
set.seed(1331)
T=200
x=rep(NA,T)
x[1]=3
phi1=0.75
for(t in 2:T){
  x[t]=phi1*x[t-1]+rnorm(1,0,sqrt(0.1))
}
S=0.001
x=x
plot(x)
```

O ajuste do modelo pode ser feito trivialmente da seguinte forma:

```{r}
# Observações sobre a especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.


# O argumento values representa o efeito do vetor latente em cada parâmetro do modelo (pois by_time=FALSE).
# Ao especificar c(1,0), estamos dizendo que este bloco tem efeito 1 (valor na matriz F) sob a média e 0 sob a log da variância.
# Ao especificar D=diag(c(1,1/0.99)), estamos dizendo que a variável theta_1 não tem dinâmica temporal e que a variável phi_1 tem dinâmica temporal especificada através do fator de desconto igual 0.99.
block1=AR_block(order=1,
                values=1,
                by_time=FALSE,
                D=diag(c(1/1,1/0.99)),
                W=diag(c(0.1,0)),
                name='AR')

model=fit_model(block1,
                outcome = x,
                family='normal',parms=list(Sigma=0))
```

Adiante exibimos a distribuição preditiva um passo-a-frente para os dados observados:

```{r}
show_fit(model,t_offset=1,smooth=FALSE)$plot
```

Pelo gráfico acima, parece que o ajuste do modelo é adequado.

Vamos avaliar agora a estimação do parâmetro $\phi_1$. Podemos verificar a distribuição de $\phi_1$ ao longo do tempo através do seguinte código:

```{r}
plot_lat_var(model,'AR')$plot
```

Podemos observar que a estimativa pontual de $\phi_1$ (em ciano) é bem próxima do valor verdadeiro, ademais, o intervalo de credibilidades para o parâmetro $\phi_1$ inclui o valor verdadeiro em todos os instantes.

Por último, antes de finalizar este exemplo, vamos exibir o ajuste sem dinâmica temporal para o $\phi_1$:

```{r}
block1=AR_block(order=1,
                values=1,
                by_time=FALSE,
                W=diag(c(0.1,0)),
                name='AR')

model=fit_model(block1,
                outcome = x,
                family='normal',
                parms=list(Sigma=0))
```


```{r}
plot_lat_var(model,'AR')$plot
```

Podemos observar no gráfico acima que, ao usar o fator de desconto $1$ para $\phi_1$, obtemos uma estimativa pontual e intervalar melhor para $\phi_1$, o que é natural, uma vez que o dados observado foi gerado de um modelo com $\phi_1$ fixo ao longo do tempo. Claro, numa situação prática, não temos acesso ao processo gerador, então não seria possível saber de antemão que não há dinâmica temporal para $\phi_1$, logo seria natural tentar fazer o ajuste do modelo com fator de desconto inferior a 1. Nesse sentido, é importante que a especificação ``incorreta" do fator de desconto (no sentido de ser diferente do processo gerador) não traz grandes prejuízos ao ajuste.

### Exemplo 3: AR(2)

Neste exemplo vamos tomar $r=2$ com $\phi_1=0.75$. A seguir apresentamos o código de simulação dos dados:

```{r}
# Gerando o dado
set.seed(1331)
T=200
x=rep(NA,T)
x[1]=rnorm(1)
x[2]=rnorm(1)
phi1=1.7
phi2=-0.9
for(t in 3:T){
  x[t]=phi1*x[t-1]+phi2*x[t-2]+rnorm(1,0,sqrt(0.01))
}
plot(x)
```

O ajuste do modelo pode ser feito da seguinte forma:

```{r}
### Modelo AR ###
# theta_i=phi1*theta_{i-1}+phi2*theta_{i-2}

# Fator de desconto para phi1
d_phi1=1
# Fator de desconto para phi2
d_phi2=1
# Fator de desconto para theta_{i-1}
d_theta1=1
# Fator de desconto para theta_{i-2}
d_theta2=1

# Variância do ruído para phi1
w_phi1=0
# Variância do ruído para phi2
w_phi2=0
# Variância do ruído para theta_{i-1}
w_theta1=0.01
# Variância do ruído para theta_{i-2}
w_theta2=0

# Especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.
block1=AR_block(order=2,
                values=1,
                by_time=FALSE,
                D=diag(c(1/d_theta1,1/d_phi1,1/d_theta2,1/d_phi2)),
                W=diag(c(w_theta1,w_phi1,w_theta2,w_phi2)),
                name='AR')
               #D=diag(c(1/0.99,1,1,1)),m0=c(0,0.1,0,0.1))

model=fit_model(block1,
                outcome = x,
                family='normal',
                parms=list(Sigma=0))
```

Exibimos adiante a previsão 1 passo-a-frente para os dados observados:

```{r}
show_fit(model,t_offset=1,smooth=FALSE)$plot
```

Veja que o ajuste do modelo parece realmente muito bom, com previsões bem precisas e intervalo de credibilidade que cobre de forma satisfatória os dados.

Vamos avaliar agora a estimação dos parâmetros $\phi_1$ $\phi_2$. Podemos verificar a distribuição dos parâmetros latentes através do seguinte código:

```{r}
plot_lat_var(model,'AR')$plot
```

Novamente, podemos observar que as estimativas pontuais e intervalares (valores latentes 2 e 4) estão boas.

Por último, antes de finalizar este exemplo, vamos exibir o ajuste com dinâmica temporal para $\phi_1$ e $phi_2$:

```{r}
### Modelo AR ###
# theta_i=phi1*theta_{i-1}+phi2*theta_{i-2}

# Fator de desconto para phi1
d_phi1=0.95
# Fator de desconto para phi2
d_phi2=0.98
# Fator de desconto para theta_{i-1}
d_theta1=1
# Fator de desconto para theta_{i-2}
d_theta2=1

# Variância do ruído para phi1
w_phi1=0
# Variância do ruído para phi2
w_phi2=0
# Variância do ruído para theta_{i-1}
w_theta1=0.01
# Variância do ruído para theta_{i-2}
w_theta2=0

# Especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.
block1=AR_block(order=2,
                values=1,
                by_time=FALSE,
                D=diag(c(1/d_theta1,1/d_phi1,1/d_theta2,1/d_phi2)),
                W=diag(c(w_theta1,w_phi1,w_theta2,w_phi2)),
                name='AR')
               #D=diag(c(1/0.99,1,1,1)),m0=c(0,0.1,0,0.1))

model=fit_model(block1,
                outcome = x,
                family='normal',
                parms=list(Sigma=0))
```


```{r}
plot_lat_var(model,'AR')$plot
```

Novamente, podemos observar que a estimativa dos parâmetros $\phi_1$ e $\phi_2$ estão excelentes!

### Exemplo 4: AR(2) com passeio aleatório

O objetivo deste exemplo é testar a capacidade do ajuste de identificar as raízes do modelo AR. Para isso vamos tomar $r=2$ simular um passeio aleatório para $\phi_1$ e $\phi_2$, sendo que queremos gerar um processo onde $\phi_1$ e $\phi_2$ passe tanto por valores nos quais o modelo tem raízes complexas como em valores em que o modelo não tem raízes complexas. Segue o código usado para gerar os dados:

```{r}
# Gerando o dado
set.seed(12353)
T=200
x=rep(NA,T)
x[1]=rnorm(1)
x[2]=rnorm(1)
phi1=1.7
phi2=-0.9
phi1_list=rep(1.7,T)
phi2_list=rep(-0.9,T)
for(t in 3:T){
  phi1=phi1_list[t-1]*1.7-0.9*phi1_list[t-2]+rnorm(1,0,sqrt(0.01))
  phi2=phi2_list[t-1]*0.75-0.1*phi2_list[t-2]+rnorm(1,-0.1,sqrt(0.01))
  phi1_list[t]=phi1
  phi2_list[t]=phi2
  x[t]=phi1*x[t-1]+phi2*x[t-2]+rnorm(1,0,sqrt(0.01))
}
x=x
```

Exibimos nos gráficos a seguir os dados observados:


```{r}
plot((1:T),x,main='Dados observados')
```

No gráfico a seguir avaliamos de que forma se distribui o comportamento das raízes do modelo para cada par de $\phi_1$ e $\phi_2$ gerados:

```{r}
plot(phi1_list,phi2_list,main=TeX('$\\phi_1 \\times \\phi_2$'),col='black',ylim=c(-1,1),xlim=c(-2,2))
lines(c(-2,2),c(-1,-1),lty=2)
lines(seq(-2,2,l=1000),-seq(-2,2,l=1000)**2/4,lty=2)
legend('topright',lty=c(NA,2),pch=c(1,NA),legend=c('Dados gerados','Fronteira da região\ncom raízes complexas'))
```

O ajuste do modelo pode ser feito da seguinte forma:

```{r}
### Modelo AR ###
# theta_i=phi1*theta_{i-1}+phi2*theta_{i-2}

# Fator de desconto para phi1
d_phi1=0.9
# Fator de desconto para phi2
d_phi2=0.9
# Fator de desconto para theta_{i-1}
d_theta1=1
# Fator de desconto para theta_{i-2}
d_theta2=1

# Variância do ruído para phi1
w_phi1=0
# Variância do ruído para phi2
w_phi2=0
# Variância do ruído para theta_{i-1}
w_theta1=0.01
# Variância do ruído para theta_{i-2}
w_theta2=0

# Especificação do choque aleatório:
#  - D especifica o fator de desconto.
#  - W especifica a matriz de covariância do ruído.
# Ordem das variáveis:
#  Para um modelo AR de ordem k, temos 2*k parametros.
#  A ordem dos parâmetros é  theta_{i-1}, phi_1, theta_{i-2}, phi_2, ... , theta_{i-k}, phi_k.
#  Ao especificar o fator de desconto ou a variância do ruído, essa ordem das variáveis deve ser levada em consideração.
block1=AR_block(order=2,
                values=1,
                by_time=FALSE,
                D=diag(c(1/d_theta1,1/d_phi1,1/d_theta2,1/d_phi2)),
                W=diag(c(w_theta1,w_phi1,w_theta2,w_phi2)),
                name='AR')
               #D=diag(c(1/0.99,1,1,1)),m0=c(0,0.1,0,0.1))

model=fit_model(block1,
                outcome = x,
                family='normal',
                parms=list(Sigma=0))
```

Exibimos adiante a previsão 1 passo-a-frente para os dados observados:

```{r}
show_fit(model,t_offset=1,smooth=FALSE)$plot
```

Vamos avaliar agora a estimação dos parâmetros $\phi_1$ $\phi_2$. Podemos verificar a distribuição dos parâmetros latentes através do seguinte código:

```{r}
plot((1:T),phi1_list,main=TeX('$\\phi_1$'),col='black',ylim=c(-1.5,2),xlim=c(1,T))
lines((1:T),model$mts[2,])
lines((1:T),model$mts[2,]+1.96*sqrt(model$Cts[2,2,]),lty=2)
lines((1:T),model$mts[2,]-1.96*sqrt(model$Cts[2,2,]),lty=2)
legend('topright',pch=c(1,NA,NA),lty=c(NA,1,2),col=c('black','black','black'),legend=c('Dados observados','Estimativa pontual','I.C. 95%'))
```

```{r}
plot((1:T),phi2_list,main=TeX('$\\phi_2$'),col='black',ylim=c(-1.5,0.5),xlim=c(1,T))
lines((1:T),model$mts[4,])
lines((1:T),model$mts[4,]+1.96*sqrt(model$Cts[4,4,]),lty=2)
lines((1:T),model$mts[4,]-1.96*sqrt(model$Cts[4,4,]),lty=2)
legend('topright',pch=c(1,NA,NA),lty=c(NA,1,2),col=c('black','black','black'),legend=c('Dados observados','Estimativa pontual','I.C. 95%'))
```

Dos ajustes acima, temos que o modelo conseguiu recuperar bem o comportamento de $\phi_1$ e $\phi_2$ ao longo do tempo. Resta apenas verificar se ele consegue recuperar os casos onde os coeficientes do AR correspondem a um modelo com raízes complexas conjugadas. No gráfico a seguir vamos compara a função $f=\phi_1^2+4\phi_2$ usando os valores reais de $\phi_1$ e $\phi_2$ e os as estimativas pontuais com o modelo ajustado. Observe que, se $f<0$, as raízes são complexas conjugadas, assim, para avaliar o quão bem o ajuste recura a informação sobre as raízes do modelo, basta olhar para o gráfico de $f$:

```{r}
f1=model$mts[2,]**2+4*model$mts[4,]
f2=phi1_list**2+4*phi2_list

plot(1:T,f1,type='l',col='red',lty=2,ylim=c(-3,2))
lines(1:T,f2)
lines(1:T,rep(0,T),lty=2)
legend('bottomright',legend=c('Ajuste','Valores reais'),lty=c(2,1),col=c('red','black'))
```

Veja que o valor estimado de $f$ é razoavelmente próximo do valor real, isto é, o modelo consegue recuperar razoavelmente bem a informação de quando os coeficientes auto-regressivos induzem a um processo estacionário ou não.
